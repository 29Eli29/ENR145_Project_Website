<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Endless Crossy Road</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB; /* Sky color */
            font-family: 'Segoe UI', sans-serif;
            touch-action: none; /* Prevent zoom on mobile */
        }
        
        #game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: 900;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }

        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            font-family: 'Segoe UI', sans-serif;
            z-index: 20;
        }

        #game-over h2 { margin: 0 0 10px 0; color: #333; }
        #game-over button {
            background: #54a0ff;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 0 #2e86de;
        }
        #game-over button:active {
            transform: translateY(4px);
            box-shadow: none;
        }
        
        /* Mobile Controls Overlay */
        #controls {
            display: none; /* Shown on touch devices usually, but hidden for desktop focus */
        }
    </style>
</head>
<body>

    <div id="game-ui">
        SCORE: <span id="score">0</span>
    </div>

    <div id="game-over">
        <h2>SPLAT!</h2>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="resetGame()">TRY AGAIN</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- CONFIGURATION ---
        const TILE_SIZE = 40;
        const VIEW_DISTANCE = 16; // How many rows we see
        const COLS = 15; // Width of the world
        
        // --- STATE ---
        let lanes = []; // The infinite map
        let particles = []; // Splat effects
        let frameCount = 0;
        let isGameOver = false;
        let score = 0;
        
        // Player State
        let player = {
            gridX: Math.floor(COLS / 2),
            gridY: 0, // Progress forward
            x: 0, // Visual X (animated)
            y: 0, // Visual Y (animated)
            z: 0, // Jump height
            isHopping: false,
            hopStartFrame: 0,
            direction: 0, // 0=up, 1=right, 2=down, 3=left
            state: 'idle' // idle, hopping, dead
        };

        // Camera
        let cameraY = 0;

        // --- RESIZING ---
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.imageSmoothingEnabled = false;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- VOXEL GRAPHICS HELPER ---
        // Draws a pseudo-3D block
        function drawBlock(x, y, z, width, height, color, sideColor) {
            // Isometric-ish projection
            // We are using a flat 2D grid but adding "depth" by drawing the front face
            let screenX = (canvas.width / 2) + (x - (COLS * TILE_SIZE)/2);
            let screenY = (canvas.height / 2) - (y - cameraY) + (VIEW_DISTANCE/2 * TILE_SIZE);

            // Draw shadow
            ctx.fillStyle = 'rgba(0,0,0,0.2)';
            ctx.fillRect(screenX + 5, screenY + 5, width, height);

            // Draw Side (Depth)
            if (z > 0) {
                ctx.fillStyle = sideColor || shadeColor(color, -20);
                ctx.fillRect(screenX, screenY + height, width, z);
            }
            
            // Draw Top
            ctx.fillStyle = color;
            ctx.fillRect(screenX, screenY + height - z, width, height); // Shift up by Z
        }

        // Helper to darken colors for sides
        function shadeColor(color, percent) {
            let num = parseInt(color.replace("#",""),16),
            amt = Math.round(2.55 * percent),
            R = (num >> 16) + amt,
            B = ((num >> 8) & 0x00FF) + amt,
            G = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (B<255?B<1?0:B:255)*0x100 + (G<255?G<1?0:G:255)).toString(16).slice(1);
        }

        // --- MAP GENERATION ---
        
        class Lane {
            constructor(index) {
                this.index = index; // The Y coordinate of this lane
                this.type = 'grass'; 
                this.obstacles = [];
                this.cars = [];
                this.speed = 0;
                this.direction = 1;
                
                // Difficulty scaling
                let difficulty = Math.min(1 + (index / 100), 3); // Caps at 3x speed

                // Determine Type
                let rand = Math.random();
                if (index < 3) {
                    this.type = 'grass'; // Start area safe
                } else {
                    if (rand < 0.4) this.type = 'grass';
                    else if (rand < 0.9) this.type = 'road';
                    else this.type = 'rail'; // Rare
                }

                // Setup Content
                if (this.type === 'grass') {
                    // Trees
                    let treeCount = Math.floor(Math.random() * 4);
                    for(let i=0; i<treeCount; i++) {
                        this.obstacles.push({
                            x: Math.floor(Math.random() * COLS),
                            type: 'tree'
                        });
                    }
                } else if (this.type === 'road') {
                    this.speed = (Math.random() * 2 + 1) * difficulty;
                    this.direction = Math.random() > 0.5 ? 1 : -1;
                    
                    // Add cars
                    let carCount = Math.floor(Math.random() * 2) + 1;
                    for(let i=0; i<carCount; i++) {
                        this.cars.push({
                            x: Math.random() * (COLS * TILE_SIZE),
                            width: TILE_SIZE + Math.random() * TILE_SIZE, // Random length
                            color: ['#ff4757', '#2ed573', '#1e90ff', '#ffa502'][Math.floor(Math.random() * 4)]
                        });
                    }
                }
            }

            update() {
                if (this.type === 'road') {
                    this.cars.forEach(car => {
                        car.x += this.speed * this.direction;
                        // Wrap around
                        let laneWidth = COLS * TILE_SIZE;
                        if (this.direction === 1 && car.x > laneWidth) car.x = -car.width;
                        if (this.direction === -1 && car.x < -car.width) car.x = laneWidth;
                    });
                }
            }
        }

        // --- GAME LOGIC ---

        function initGame() {
            lanes = [];
            player.gridY = 0;
            player.gridX = Math.floor(COLS / 2);
            player.state = 'idle';
            isGameOver = false;
            score = 0;
            cameraY = 0;
            document.getElementById('score').innerText = "0";
            document.getElementById('game-over').style.display = 'none';

            // Pre-generate starting lanes
            for(let i=0; i<VIEW_DISTANCE + 5; i++) {
                lanes.push(new Lane(i));
            }
        }

        function getLane(gridY) {
            // Find lane in array (since array shifts, we match by index property)
            // But to optimize, we just keep adding to the array and cleanup later
            // For this simple version, we'll just check if it exists
            if (gridY >= lanes.length) {
                // Generate new lanes on demand
                for (let i = lanes.length; i <= gridY + 5; i++) {
                    lanes.push(new Lane(i));
                }
            }
            return lanes[gridY]; // Assumes lanes are never deleted from start (for simplicity here)
        }

        function checkCollision(nextX, nextY) {
            // 1. Boundary Check
            if (nextX < 0 || nextX >= COLS) return true;

            // 2. Obstacle Check (Trees)
            let lane = getLane(nextY);
            if (lane) {
                for (let obs of lane.obstacles) {
                    if (obs.x === nextX) return true;
                }
            }
            return false;
        }

        function hop(dx, dy) {
            if (player.state !== 'idle') return;

            // Determine direction for sprite rotation (not implemented visually yet, but good for logic)
            if (dy > 0) player.direction = 0; // Forward
            else if (dy < 0) player.direction = 2; // Back
            else if (dx > 0) player.direction = 1; // Right
            else if (dx < 0) player.direction = 3; // Left

            let targetX = player.gridX + dx;
            let targetY = player.gridY + dy;

            // Prevent moving backwards too far (camera lock)
            if (targetY < Math.floor(cameraY / TILE_SIZE) - 2) return;

            if (!checkCollision(targetX, targetY)) {
                player.state = 'hopping';
                player.hopStartFrame = frameCount;
                player.targetX = targetX;
                player.targetY = targetY;
                
                // Update score if moving forward
                if (targetY > score) {
                    score = targetY;
                    document.getElementById('score').innerText = score;
                }
            }
        }

        // --- RENDERING ---

        function drawChicken(px, py, pz) {
            // Body
            drawBlock(px + 10, py + 10, pz + 20, 20, 20, '#fff'); 
            // Comb
            drawBlock(px + 18, py + 18, pz + 36, 4, 4, '#ff4757');
            // Beak
            if(player.direction === 1) drawBlock(px + 28, py + 15, pz + 28, 4, 4, '#ffa502'); // Right
            else drawBlock(px + 18, py + 28, pz + 28, 4, 4, '#ffa502'); // Front (default)
        }

        function drawScene() {
            // Sky
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Determine visible range
            let startRow = Math.floor(cameraY / TILE_SIZE) - 2;
            let endRow = startRow + VIEW_DISTANCE + 2;

            // Camera Smoothing
            let targetCamY = (player.y - (TILE_SIZE * 4)); 
            // Linear interpolation for smooth camera
            cameraY += (targetCamY - cameraY) * 0.1;

            // DRAW WORLD (Back to Front: Top of screen to Bottom)
            // In our coordinate system, Higher Y is "further away" in the game world?
            // Actually, in this endless runner: Y=0 is start, Y=100 is far.
            // We draw from Furthest (Highest Y) to Closest (Lowest Y) so trees cover things behind them.
            
            for (let i = endRow; i >= startRow; i--) {
                if (i < 0) continue;
                let lane = getLane(i);
                if (!lane) continue;

                let ly = i * TILE_SIZE;

                // 1. Draw Ground
                let color = '#7bed9f'; // Grass
                let sideColor = '#2ed573';
                if (lane.type === 'road') { color = '#57606f'; sideColor = '#2f3542'; }
                if ((i % 2) !== 0 && lane.type === 'grass') { color = '#70a1ff'; sideColor = '#1e90ff'; } // Stripe grass slightly

                // Draw the full lane strip
                drawBlock(0, ly, 0, COLS * TILE_SIZE, TILE_SIZE, color, sideColor);

                // Road Markings
                if (lane.type === 'road') {
                    ctx.fillStyle = '#fff';
                    let screenY = (canvas.height / 2) - (ly - cameraY) + (VIEW_DISTANCE/2 * TILE_SIZE);
                    let screenXBase = (canvas.width / 2) - ((COLS * TILE_SIZE)/2);
                    ctx.fillRect(screenXBase, screenY + TILE_SIZE - 5, COLS*TILE_SIZE, 2);
                }

                // 2. Draw Obstacles (Trees)
                lane.obstacles.forEach(obs => {
                    let ox = obs.x * TILE_SIZE;
                    // Trunk
                    drawBlock(ox + 10, ly + 10, 10, 20, 20, '#8d6e63');
                    // Leaves
                    drawBlock(ox + 5, ly + 5, 20, 30, 30, '#2ecc71', '#27ae60');
                    drawBlock(ox + 10, ly + 10, 40, 20, 20, '#2ecc71', '#27ae60');
                });

                // 3. Draw Cars
                if (lane.type === 'road') {
                    lane.cars.forEach(car => {
                        let cx = car.x;
                        drawBlock(cx, ly + 5, 12, car.width, TILE_SIZE - 10, car.color);
                        // Windows
                        ctx.fillStyle = '#333';
                        let screenY = (canvas.height / 2) - (ly - cameraY) + (VIEW_DISTANCE/2 * TILE_SIZE);
                        let screenX = (canvas.width / 2) + (cx - (COLS * TILE_SIZE)/2);
                        // Very rough absolute positioning for detail on top of canvas draw
                    });
                }

                // 4. Draw Player (If on this row)
                // We draw player "in" the loop so they can be covered by trees in front of them
                // But player Y is fluid (animated). 
                // We draw player when we process the row closest to player's current visual Y
                if (Math.round(player.y / TILE_SIZE) === i) {
                    drawChicken(player.x, player.y, player.z);
                }
            }
        }

        function updatePhysics() {
            if (isGameOver) return;

            // Handle Hopping
            if (player.state === 'hopping') {
                let animationSpeed = 0.15; // 0 to 1 progress
                let progress = (frameCount - player.hopStartFrame) * animationSpeed;
                
                if (progress >= 1) {
                    player.state = 'idle';
                    player.gridX = player.targetX;
                    player.gridY = player.targetY;
                    player.x = player.gridX * TILE_SIZE;
                    player.y = player.gridY * TILE_SIZE;
                    player.z = 0;
                } else {
                    // Linear movement
                    player.x = (player.gridX * TILE_SIZE) * (1 - progress) + (player.targetX * TILE_SIZE) * progress;
                    player.y = (player.gridY * TILE_SIZE) * (1 - progress) + (player.targetY * TILE_SIZE) * progress;
                    // Parabolic arc for Z (Height)
                    player.z = Math.sin(progress * Math.PI) * 20;
                }
            } else {
                // Sync visual to grid if idle
                player.x = player.gridX * TILE_SIZE;
                player.y = player.gridY * TILE_SIZE;
            }

            // Check Car Collisions
            let currentLane = getLane(Math.round(player.y / TILE_SIZE));
            if (currentLane && currentLane.type === 'road') {
                let px = player.x + 10;
                let pw = 20;
                
                for(let car of currentLane.cars) {
                    // Simple AABB
                    if (px < car.x + car.width && px + pw > car.x) {
                        isGameOver = true;
                        document.getElementById('final-score').innerText = score;
                        document.getElementById('game-over').style.display = 'block';
                    }
                }
            }
        }

        function loop() {
            frameCount++;
            if (!isGameOver) {
                // Update lanes
                lanes.forEach(l => l.update());
                updatePhysics();
            }
            drawScene();
            requestAnimationFrame(loop);
        }

        // --- CONTROLS ---
        window.addEventListener('keydown', e => {
            if (isGameOver) return;
            switch(e.key) {
                case 'ArrowUp': hop(0, 1); break;
                case 'ArrowDown': hop(0, -1); break;
                case 'ArrowLeft': hop(-1, 0); break;
                case 'ArrowRight': hop(1, 0); break;
            }
        });
        
        // Touch controls for mobile
        let touchStartX = 0;
        let touchStartY = 0;
        window.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});
        
        window.addEventListener('touchend', e => {
            if (isGameOver) return;
            let dx = e.changedTouches[0].screenX - touchStartX;
            let dy = e.changedTouches[0].screenY - touchStartY;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                if(dx > 30) hop(1,0);
                else if(dx < -30) hop(-1,0);
            } else {
                if(dy > 30) hop(0,-1); // Swipe down
                else if(dy < -30) hop(0,1); // Swipe up (Forward)
            }
        }, {passive: false});

        function resetGame() {
            initGame();
        }

        // Start
        initGame();
        loop();

    </script>
</body>
</html>
