!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Voxel Crossy Road</title>
    <style>
        :root {
            --primary: #54a0ff;
            --primary-dark: #2e86de;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 10;
            pointer-events: none;
        }
        #score-label {
            font-size: 48px;
            font-weight: 900;
            text-shadow: 3px 3px 0px rgba(0,0,0,0.2);
            margin: 0;
        }
        #overlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.3);
            z-index: 100;
            min-width: 200px;
        }
        #overlay h2 {
            margin: 0 0 10px;
            font-size: 32px;
            color: #333;
        }
        #overlay p {
            font-size: 20px;
            color: #666;
            margin-bottom: 25px;
        }
        button {
            background: var(--primary);
            border: none;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 6px 0 var(--primary-dark);
            transition: all 0.1s;
        }
        button:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 var(--primary-dark);
        }
        #controls-hint {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <p id="score-label">0</p>
    </div>

    <div id="overlay">
        <h2 id="status-text">SPLAT!</h2>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="resetGame()">PLAY AGAIN</button>
    </div>

    <div id="controls-hint">ARROW KEYS TO MOVE â€¢ SWIPE ON MOBILE</div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- CONSTANTS ---
        const TILE_SIZE = 50;
        const COLS = 11; 
        const VISIBLE_ROWS = 15;
        
        // --- GAME STATE ---
        let lanes = [];
        let score = 0;
        let isGameOver = false;
        let frame = 0;
        let cameraY = 0;
        
        const player = {
            gridX: Math.floor(COLS / 2),
            gridY: 0,
            visualX: 0,
            visualY: 0,
            visualZ: 0,
            targetX: Math.floor(COLS / 2),
            targetY: 0,
            isHopping: false,
            hopProgress: 0,
            rotation: 0 // 0: Up, 1: Right, 2: Down, 3: Left
        };

        // --- VOXEL RENDERER ---
        function drawCube(x, y, z, w, h, d, topColor, sideColor, frontColor) {
            // Project world coordinates to screen
            // Isometric-lite projection
            const screenX = (canvas.width / 2) + (x - (COLS * TILE_SIZE) / 2);
            const screenY = (canvas.height * 0.75) - (y - cameraY);

            // Shadow
            if (d === 0) { // On ground
                ctx.fillStyle = 'rgba(0,0,0,0.15)';
                ctx.fillRect(screenX + 4, screenY - h + 4, w, h);
            }

            // Side face (right)
            ctx.fillStyle = sideColor || shadeColor(topColor, -20);
            ctx.beginPath();
            ctx.moveTo(screenX + w, screenY);
            ctx.lineTo(screenX + w, screenY - h);
            ctx.lineTo(screenX + w + 10, screenY - h - 10);
            ctx.lineTo(screenX + w + 10, screenY - 10);
            ctx.fill();

            // Top face
            ctx.fillStyle = topColor;
            ctx.beginPath();
            ctx.moveTo(screenX, screenY - h);
            ctx.lineTo(screenX + w, screenY - h);
            ctx.lineTo(screenX + w + 10, screenY - h - 10);
            ctx.lineTo(screenX + 10, screenY - h - 10);
            ctx.fill();

            // Front face
            ctx.fillStyle = frontColor || shadeColor(topColor, -10);
            ctx.fillRect(screenX, screenY - h, w, h);
        }

        function shadeColor(color, percent) {
            let num = parseInt(color.replace("#",""),16),
                amt = Math.round(2.55 * percent),
                R = (num >> 16) + amt,
                G = (num >> 8 & 0x00FF) + amt,
                B = (num & 0x0000FF) + amt;
            return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
        }

        // --- LANE LOGIC ---
        class Lane {
            constructor(index) {
                this.index = index;
                this.y = index * TILE_SIZE;
                this.obstacles = [];
                this.entities = [];
                
                // Set lane type
                const r = Math.random();
                if (index < 4) {
                    this.type = 'grass';
                } else {
                    if (r < 0.35) this.type = 'grass';
                    else if (r < 0.85) this.type = 'road';
                    else this.type = 'water';
                }

                this.setup();
            }

            setup() {
                const difficulty = Math.min(1 + (this.index / 100), 2.5);
                
                if (this.type === 'grass') {
                    // Random trees
                    for (let i = 0; i < COLS; i++) {
                        if (Math.random() < 0.2) {
                            if (this.index === 0 && i === Math.floor(COLS/2)) continue;
                            this.obstacles.push({ x: i, type: 'tree' });
                        }
                    }
                } else if (this.type === 'road') {
                    this.speed = (1.5 + Math.random() * 2) * difficulty;
                    this.dir = Math.random() > 0.5 ? 1 : -1;
                    const carCount = Math.floor(Math.random() * 2) + 2;
                    const color = ['#ff4757', '#eccc68', '#70a1ff', '#ffffff'][Math.floor(Math.random() * 4)];
                    
                    for (let i = 0; i < carCount; i++) {
                        this.entities.push({
                            x: Math.random() * (COLS * TILE_SIZE),
                            w: TILE_SIZE * (1.2 + Math.random() * 0.8),
                            color: color
                        });
                    }
                } else if (this.type === 'water') {
                    this.speed = (1 + Math.random() * 1) * difficulty;
                    this.dir = Math.random() > 0.5 ? 1 : -1;
                    const logCount = 3;
                    for (let i = 0; i < logCount; i++) {
                        this.entities.push({
                            x: (i * (COLS * TILE_SIZE / logCount)),
                            w: TILE_SIZE * 2,
                            color: '#8d6e63'
                        });
                    }
                }
            }

            update() {
                if (this.type === 'road' || this.type === 'water') {
                    this.entities.forEach(ent => {
                        ent.x += this.speed * this.dir;
                        const totalWidth = COLS * TILE_SIZE;
                        if (this.dir === 1 && ent.x > totalWidth) ent.x = -ent.w;
                        if (this.dir === -1 && ent.x < -ent.w) ent.x = totalWidth;
                    });
                }
            }

            draw() {
                const ly = this.y;
                
                // Ground
                let gCol = '#7bed9f';
                if (this.type === 'road') gCol = '#57606f';
                if (this.type === 'water') gCol = '#1e90ff';
                if (this.type === 'grass' && this.index % 2 === 0) gCol = '#6ab04c';

                drawCube(0, ly, 0, COLS * TILE_SIZE, TILE_SIZE, 5, gCol);

                // Obstacles (Trees)
                this.obstacles.forEach(tree => {
                    const tx = tree.x * TILE_SIZE;
                    drawCube(tx + 15, ly + 15, 0, 20, 20, 20, '#5d4037'); // Trunk
                    drawCube(tx + 5, ly + 5, 20, 40, 40, 30, '#2ecc71'); // Leaves
                });

                // Entities (Cars/Logs)
                this.entities.forEach(ent => {
                    if (this.type === 'road') {
                        drawCube(ent.x, ly + 5, 0, ent.w, TILE_SIZE - 10, 25, ent.color);
                    } else {
                        drawCube(ent.x, ly + 2, 0, ent.w, TILE_SIZE - 4, 10, ent.color);
                    }
                });
            }
        }

        // --- CORE FUNCTIONS ---
        function initGame() {
            lanes = [];
            score = 0;
            isGameOver = false;
            cameraY = 0;
            
            player.gridX = Math.floor(COLS / 2);
            player.gridY = 0;
            player.visualX = player.gridX * TILE_SIZE;
            player.visualY = 0;
            player.visualZ = 0;
            player.isHopping = false;
            
            document.getElementById('score-label').innerText = '0';
            document.getElementById('overlay').style.display = 'none';

            for (let i = 0; i < VISIBLE_ROWS + 5; i++) {
                lanes.push(new Lane(i));
            }
        }

        function getLane(y) {
            while (y >= lanes.length) {
                lanes.push(new Lane(lanes.length));
            }
            return lanes[y];
        }

        function move(dx, dy) {
            if (isGameOver || player.isHopping) return;

            const nextX = player.gridX + dx;
            const nextY = player.gridY + dy;

            if (nextX < 0 || nextX >= COLS) return;
            if (nextY < Math.floor(cameraY / TILE_SIZE)) return;

            // Tree collision
            const lane = getLane(nextY);
            if (lane.type === 'grass' && lane.obstacles.some(o => o.x === nextX)) return;

            // Set animation
            player.targetX = nextX;
            player.targetY = nextY;
            player.isHopping = true;
            player.hopProgress = 0;

            if (dy > 0) player.rotation = 0;
            else if (dy < 0) player.rotation = 2;
            else if (dx > 0) player.rotation = 1;
            else if (dx < 0) player.rotation = 3;
        }

        function update() {
            if (isGameOver) return;

            // Camera follow
            const targetCam = player.visualY - 150;
            cameraY += (targetCam - cameraY) * 0.1;

            // Lane updates
            lanes.forEach(l => l.update());

            // Player Animation
            if (player.isHopping) {
                player.hopProgress += 0.15;
                if (player.hopProgress >= 1) {
                    player.isHopping = false;
                    player.gridX = player.targetX;
                    player.gridY = player.targetY;
                    player.visualX = player.gridX * TILE_SIZE;
                    player.visualY = player.gridY * TILE_SIZE;
                    player.visualZ = 0;
                    
                    if (player.gridY > score) {
                        score = player.gridY;
                        document.getElementById('score-label').innerText = score;
                    }
                } else {
                    player.visualX = (player.gridX * TILE_SIZE) + (player.targetX - player.gridX) * TILE_SIZE * player.hopProgress;
                    player.visualY = (player.gridY * TILE_SIZE) + (player.targetY - player.gridY) * TILE_SIZE * player.hopProgress;
                    player.visualZ = Math.sin(player.hopProgress * Math.PI) * 25;
                }
            }

            // Collision Detection
            const curLane = getLane(Math.round(player.visualY / TILE_SIZE));
            if (curLane.type === 'road') {
                const pw = 30;
                const px = player.visualX + 10;
                if (curLane.entities.some(car => px < car.x + car.w && px + pw > car.x)) {
                    triggerGameOver();
                }
            } else if (curLane.type === 'water') {
                const px = player.visualX + 25;
                const onLog = curLane.entities.find(log => px > log.x && px < log.x + log.w);
                if (onLog) {
                    player.visualX += curLane.speed * curLane.dir;
                    player.gridX = Math.round(player.visualX / TILE_SIZE);
                } else if (!player.isHopping) {
                    triggerGameOver();
                }
            }
            
            // Out of bounds check (pushed by log)
            if (player.visualX < -20 || player.visualX > (COLS * TILE_SIZE)) {
                triggerGameOver();
            }
        }

        function triggerGameOver() {
            isGameOver = true;
            document.getElementById('final-score').innerText = score;
            document.getElementById('overlay').style.display = 'block';
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const start = Math.max(0, Math.floor(cameraY / TILE_SIZE) - 2);
            const end = start + VISIBLE_ROWS;

            for (let i = start; i < end; i++) {
                const lane = getLane(i);
                lane.draw();

                // Draw Player on correct layer
                if (i === Math.round(player.visualY / TILE_SIZE)) {
                    // Chicken Body
                    drawCube(player.visualX + 10, player.visualY + 10, player.visualZ, 30, 30, 35, '#fff');
                    // Comb
                    drawCube(player.visualX + 20, player.visualY + 20, player.visualZ + 35, 10, 10, 5, '#ff4757');
                    // Beak
                    drawCube(player.visualX + 22, player.visualY + 35, player.visualZ + 20, 6, 8, 6, '#ffa502');
                }
            }
        }

        function resetGame() {
            initGame();
        }

        // --- INPUTS ---
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowUp') move(0, 1);
            if (e.key === 'ArrowDown') move(0, -1);
            if (e.key === 'ArrowLeft') move(-1, 0);
            if (e.key === 'ArrowRight') move(1, 0);
        });

        let tsX, tsY;
        window.addEventListener('touchstart', e => {
            tsX = e.touches[0].clientX;
            tsY = e.touches[0].clientY;
        });
        window.addEventListener('touchend', e => {
            const dx = e.changedTouches[0].clientX - tsX;
            const dy = e.changedTouches[0].clientY - tsY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > 30) move(dx > 0 ? 1 : -1, 0);
            } else {
                if (Math.abs(dy) > 30) move(0, dy > 0 ? -1 : 1);
            }
        });

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        initGame();
        loop();
    </script>
</body>
</html>
