<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GLOWPHASE: TITAN</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #000;
            font-family: 'Orbitron', sans-serif;
            color: white; user-select: none;
        }

        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* HUD */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; z-index: 10;
        }

        .hud-top {
            display: flex; justify-content: space-between; padding: 30px;
            font-size: 20px; letter-spacing: 2px;
            text-shadow: 0 0 10px currentColor;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
        }

        #score-display { color: #fff; }
        #currency-display { color: #ffff00; text-shadow: 0 0 10px #ffff00; } 
        #speed-display { color: #00ffcc; }

        #mode-indicator {
            position: absolute; bottom: 120px; left: 50%;
            transform: translateX(-50%); padding: 15px 40px;
            border: 2px solid; border-radius: 2px;
            font-weight: 900; font-size: 24px; letter-spacing: 4px;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            background: rgba(0,0,0,0.8);
            clip-path: polygon(15% 0, 100% 0, 85% 100%, 0% 100%);
            text-transform: uppercase;
        }
        .mode-solid { 
            border-color: #00ffff; color: #00ffff; /* CYAN for Solid */
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.4), inset 0 0 20px rgba(0, 255, 255, 0.2); 
        }
        .mode-ethereal { 
            border-color: #ff0044; color: #ff0044; /* RED for Ethereal */
            box-shadow: 0 0 30px rgba(255, 0, 68, 0.4), inset 0 0 20px rgba(255, 0, 68, 0.2); 
        }

        /* MENUS */
        #start-screen, #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 20; pointer-events: auto; overflow: hidden;
            background: #020205;
            transition: opacity 0.5s;
        }

        /* Neural Background Animation */
        .neural-bg {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 50% 50%, #1a0b1a 0%, #000 100%);
            z-index: -1; opacity: 0.8;
        }
        .neural-node {
            position: absolute; border-radius: 50%;
            background: #ff0044; box-shadow: 0 0 10px #ff0044;
            animation: floatNode 10s infinite ease-in-out;
        }
        @keyframes floatNode {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.3; }
            50% { transform: translate(20px, -20px) scale(1.5); opacity: 0.8; }
        }

        /* CRT Effect for Game Over */
        .crt-overlay {
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
        }

        h1 {
            font-size: 100px; margin: 0; color: #fff; text-transform: uppercase;
            letter-spacing: 15px; position: relative; z-index: 2;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            mix-blend-mode: overlay;
        }

        .title-glitch {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            font-size: 100px; color: #ff0044; letter-spacing: 15px;
            opacity: 0.5; z-index: 1; mix-blend-mode: color-dodge;
            animation: glitch-anim 2s infinite linear alternate-reverse;
        }

        @keyframes glitch-anim {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

        .menu-box {
            margin-top: 40px;
            background: rgba(255, 255, 255, 0.03); 
            backdrop-filter: blur(20px);
            padding: 50px 80px; 
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #ff0044;
            border-bottom: 4px solid #00ffff;
            box-shadow: 0 0 50px rgba(0,0,0,0.8); 
            text-align: center; z-index: 5;
            position: relative;
        }

        .menu-box::before {
            content: ''; position: absolute; top: -10px; left: -10px;
            width: 20px; height: 20px; border-top: 2px solid #fff; border-left: 2px solid #fff;
        }
        .menu-box::after {
            content: ''; position: absolute; bottom: -10px; right: -10px;
            width: 20px; height: 20px; border-bottom: 2px solid #fff; border-right: 2px solid #fff;
        }

        .space-prompt {
            margin-top: 40px; font-size: 20px; color: #fff;
            animation: pulse 0.8s infinite alternate; 
            font-weight: 900; letter-spacing: 4px;
            background: #fff; color: #000; padding: 5px 15px;
        }
        @keyframes pulse { 0% { opacity: 0.8; transform: scale(0.98); } 100% { opacity: 1; transform: scale(1.02); box-shadow: 0 0 20px #fff; } }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-container"></div>

<div id="ui-layer">
    <div class="hud-top">
        <div id="score-display">SCORE: 0000</div>
        <div id="currency-display">GLOW: 0</div>
        <div id="speed-display">VELOCITY: 100%</div>
    </div>
    <div id="mode-indicator" class="mode-solid">SOLID FORM</div>
</div>

<div id="start-screen">
    <div class="neural-bg" id="neural-bg">
        <!-- JS will populate nodes -->
    </div>
    
    <div style="position:relative;">
        <h1>GLOWPHASE</h1>
        <div class="title-glitch">GLOWPHASE</div>
    </div>
    
    <div style="font-size: 24px; color: #00ffff; letter-spacing: 10px; margin-bottom: 20px; text-shadow: 0 0 10px #00ffff;">
        TITAN PROTOCOL
    </div>
    
    <div class="menu-box">
        <p style="color:#ddd; font-size:16px; margin-bottom:10px; line-height: 1.6;">
            The city has evolved. Watch for Gaps.<br>
            <span style="color:#ff0044; font-weight:bold;">JUMPING IS FUTILE.</span> You must Phase.
        </p>
        <p style="font-size: 14px; color: #888;">
            <span style="border: 1px solid #00ffff; color:#00ffff; padding: 2px 6px;">SPACE</span> JUMP &nbsp; 
            <span style="border: 1px solid #ff0044; color:#ff0044; padding: 2px 6px;">DOWN</span> SHIFT
        </p>
        <div class="space-prompt">PRESS SPACE TO INITIALIZE</div>
    </div>
</div>

<div id="game-over-screen" class="hidden">
    <div class="crt-overlay"></div>
    <h1 style="font-size: 80px; color: #ff0044; text-shadow: 0 0 30px red;">FATAL ERROR</h1>
    <p style="font-size: 30px; color: white; letter-spacing: 5px;">SYNC LOST</p>
    <p style="font-size: 40px; color: #00ffff; margin: 30px 0;">SCORE: <span id="final-score">0</span></p>
    <div class="space-prompt" style="background: #ff0044; color: #fff;">PRESS SPACE TO REBOOT</div>
</div>

<script>
    // --- Config ---
    const CONF = {
        laneWidth: 6,
        chunkLength: 50,
        floorHeight: 0,
        subLevelHeight: -6,
        skyHeight: 12,
        colors: {
            bg: 0x050011,
            armor: 0x111111,
            armorGlow: 0xff0000,
            helmet: 0x220000,
            floor: 0x222222,
            vine: 0x00ffcc,
            sky: 0x000033,
            laser: 0xff0044,
            glowStick: 0xffff00
        },
        speed: 0.65, 
        gravity: 0.05,
        jumpForce: 0.95 
    };

    let scene, camera, renderer, gameActive=false, score=0, currency=0, speed=CONF.speed, timeGlobal=0;
    let particles = []; 
    let speedLines = [];

    // --- Audio ---
    const AudioSys = {
        ctx: null,
        init: function() { 
            try { window.AudioContext = window.AudioContext || window.webkitAudioContext; if(!this.ctx && window.AudioContext) this.ctx = new AudioContext(); } catch(e){} 
        },
        resume: function() { if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); },
        playTone: function(freq, type, dur, vol=0.1) {
            if(!this.ctx) return;
            try {
                const o=this.ctx.createOscillator(), g=this.ctx.createGain();
                o.type=type; o.frequency.setValueAtTime(freq, this.ctx.currentTime);
                g.gain.setValueAtTime(vol, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime+dur);
                o.connect(g); g.connect(this.ctx.destination);
                o.start(); o.stop(this.ctx.currentTime+dur);
            } catch(e){}
        },
        playJump: function(){ this.playTone(400,'triangle',0.15,0.15); }, 
        playShift: function(){ this.playTone(800,'sine',0.2,0.15); },
        playCollect: function(){ this.playTone(1200, 'sine', 0.1, 0.1); this.playTone(1800, 'sine', 0.1, 0.1); },
        playCrash: function(){ this.playTone(100,'sawtooth',0.5,0.3); }
    };

    // --- Menu Background Gen ---
    function initMenuBG() {
        const container = document.getElementById('neural-bg');
        for(let i=0; i<20; i++) {
            const node = document.createElement('div');
            node.className = 'neural-node';
            const size = Math.random() * 10 + 5;
            node.style.width = size + 'px';
            node.style.height = size + 'px';
            node.style.left = Math.random() * 100 + '%';
            node.style.top = Math.random() * 100 + '%';
            node.style.animationDuration = (Math.random() * 5 + 5) + 's';
            node.style.backgroundColor = Math.random() > 0.5 ? '#ff0044' : '#00ffff';
            node.style.boxShadow = `0 0 15px ${node.style.backgroundColor}`;
            container.appendChild(node);
        }
    }
    initMenuBG();

    // --- Asset Generation ---
    function createGlowTexture(color) {
        const c = document.createElement('canvas'); c.width=256; c.height=256;
        const ctx = c.getContext('2d');
        ctx.fillStyle = '#050505'; 
        ctx.fillRect(0,0,256,256);
        
        ctx.strokeStyle = color; 
        ctx.lineWidth = 6;
        ctx.shadowBlur = 20; 
        ctx.shadowColor = color;
        
        ctx.beginPath();
        for(let i=0; i<8; i++) {
            ctx.moveTo(Math.random()*256, 0); ctx.lineTo(Math.random()*256, 256);
        }
        ctx.stroke();
        ctx.strokeRect(0,0,256,256); 
        
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        return tex;
    }
    const floorTex = createGlowTexture('#00ffcc');

    // --- Visual Effects ---
    class SpeedLine {
        constructor() {
            const geometry = new THREE.BoxGeometry(0.1, 0.1, 10);
            const material = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
            this.mesh = new THREE.Mesh(geometry, material);
            this.reset();
            scene.add(this.mesh);
        }
        reset() {
            this.mesh.position.set(
                (Math.random() - 0.5) * 40,
                (Math.random() - 0.5) * 20 + 5,
                player ? player.container.position.z - 50 : -50
            );
            this.speed = Math.random() * 2 + 1;
        }
        update(playerZ) {
            this.mesh.position.z += this.speed; 
            if (this.mesh.position.z > playerZ + 20) {
                this.mesh.position.z = playerZ - 100 - Math.random() * 50;
                this.mesh.position.x = (Math.random() - 0.5) * 40;
                this.mesh.position.y = (Math.random() - 0.5) * 20 + 5;
            }
        }
    }

    class PhaseEffect {
        constructor(position, color) {
            this.mesh = new THREE.Group();
            this.active = true;
            this.life = 1.0;
            
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const mat = new THREE.MeshBasicMaterial({ color: color });

            for(let i=0; i<20; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(position);
                p.userData.vel = new THREE.Vector3(
                    (Math.random()-0.5)*0.8,
                    (Math.random()-0.5)*0.8,
                    (Math.random()-0.5)*0.8
                );
                this.mesh.add(p);
            }
            scene.add(this.mesh);
        }
        update() {
            this.life -= 0.05;
            if(this.life <= 0) {
                this.active = false;
                scene.remove(this.mesh);
                return;
            }
            this.mesh.children.forEach(p => {
                p.position.add(p.userData.vel);
                p.scale.setScalar(this.life);
                p.rotation.x += 0.1;
            });
        }
    }

    // --- World Management ---
    class ChunkManager {
        constructor() {
            this.chunks = [];
            this.nextZ = 0;
        }

        reset() {
            this.chunks.forEach(c => scene.remove(c.mesh));
            this.chunks = [];
            this.nextZ = 0;
            for(let i=0; i<4; i++) this.addChunk('flat');
        }

        addChunk(type) {
            const zStart = this.nextZ;
            const zEnd = this.nextZ - CONF.chunkLength;
            
            const chunk = { type: type, zStart: zStart, zEnd: zEnd, mesh: new THREE.Group() };
            // Added emissive for better visibility of gaps
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0x444444, 
                map: floorTex, 
                roughness: 0.4, 
                metalness: 0.8,
                emissive: 0x002222, // Low glow for better gap visibility
                emissiveIntensity: 0.5
            });

            const H_BASE = CONF.floorHeight;
            const H_SUB = CONF.subLevelHeight;
            const H_HIGH = CONF.skyHeight;
            const WIDTH = CONF.laneWidth * 3 + 4; 

            // GLITCH FIX: Use PlaneGeometry for floors to avoid corner protrusion clipping
            const createFloor = (y, startZOffset=0, length=CONF.chunkLength) => {
                // Main Surface (Plane)
                const floorGeo = new THREE.PlaneGeometry(WIDTH, length);
                const floor = new THREE.Mesh(floorGeo, mat);
                floor.rotation.x = -Math.PI / 2; // Flat by default
                floor.position.set(0, y, zStart - startZOffset - length/2);
                chunk.mesh.add(floor);

                // Underside Box (For visual thickness, offset down)
                const underBox = new THREE.Mesh(new THREE.BoxGeometry(WIDTH, 2, length), new THREE.MeshBasicMaterial({color: 0x111111}));
                underBox.position.set(0, y - 1.01, zStart - startZOffset - length/2); 
                chunk.mesh.add(underBox);

                return { mesh: floor, under: underBox };
            }

            const createCeiling = (y, startZOffset=0, length=CONF.chunkLength) => {
                const ceilGeo = new THREE.PlaneGeometry(WIDTH, length);
                const ceil = new THREE.Mesh(ceilGeo, mat);
                ceil.rotation.x = Math.PI / 2; 
                ceil.position.set(0, y, zStart - startZOffset - length/2);
                chunk.mesh.add(ceil);
                
                const overBox = new THREE.Mesh(new THREE.BoxGeometry(WIDTH, 2, length), new THREE.MeshBasicMaterial({color: 0x111111}));
                overBox.position.set(0, y + 1.01, zStart - startZOffset - length/2);
                chunk.mesh.add(overBox);
            }

            // Height Differences
            const D_SUB = Math.abs(H_BASE - H_SUB); 
            const D_SKY = Math.abs(H_HIGH - H_BASE); 

            if (type === 'flat') {
                createFloor(H_BASE);
                createCeiling(H_BASE + 22); // Height adjusted to 22 (Not too low, not too high)
                this.addWalls(chunk.mesh, H_BASE, zStart, 0xff00cc);
            }
            else if (type === 'gap_base') {
                createFloor(H_BASE, 0, 15);
                createFloor(H_BASE, 35, 15);
                createCeiling(H_BASE + 22);
                this.addWalls(chunk.mesh, H_BASE, zStart, 0xff0000);
                
                world.spawnCollectible(zStart - 25, 0, H_BASE + 4);
                world.spawnCollectible(zStart - 25, -CONF.laneWidth, H_BASE + 6);
                world.spawnCollectible(zStart - 25, CONF.laneWidth, H_BASE + 6);
            }
            else if (type === 'high_level') {
                createFloor(H_HIGH);
                createCeiling(H_HIGH + 22);
                // No walls on high level for open feel
            }
            else if (type === 'sub_level') {
                createFloor(H_SUB);
                createCeiling(H_SUB + 22);
                this.addWalls(chunk.mesh, H_SUB, zStart, 0x00aaff);
            }
            else if (type === 'gap_sub') {
                 createFloor(H_SUB, 0, 15);
                 createFloor(H_SUB, 35, 15);
                 createCeiling(H_SUB + 22);
                 this.addWalls(chunk.mesh, H_SUB, zStart, 0xff0000);
                 world.spawnCollectible(zStart - 25, 0, H_SUB + 4);
            }
            // RAMP: DOWN to SUB
            else if (type === 'ramp_down_sub') {
                const len = Math.sqrt(CONF.chunkLength**2 + D_SUB**2);
                const angle = Math.atan(D_SUB / CONF.chunkLength);
                
                const floorGeo = new THREE.PlaneGeometry(WIDTH, len);
                const ramp = new THREE.Mesh(floorGeo, mat);
                const midY = (H_BASE + H_SUB) / 2;
                ramp.position.set(0, midY, zStart - CONF.chunkLength/2);
                ramp.rotation.x = -Math.PI/2 - angle; 
                chunk.mesh.add(ramp);

                const thick = new THREE.Mesh(new THREE.BoxGeometry(WIDTH, 2, len), new THREE.MeshBasicMaterial({color:0x111111}));
                thick.position.copy(ramp.position);
                thick.rotation.x = ramp.rotation.x;
                thick.translateY(-1.0);
                chunk.mesh.add(thick);
                
                // Roof Ramp
                const roofRamp = thick.clone();
                roofRamp.position.y += 22; 
                chunk.mesh.add(roofRamp);
                
                this.addWalls(chunk.mesh, midY, zStart, 0xaa00ff, true);
            }
            // RAMP: UP from SUB
            else if (type === 'ramp_up_base') {
                const len = Math.sqrt(CONF.chunkLength**2 + D_SUB**2);
                const angle = Math.atan(D_SUB / CONF.chunkLength);
                
                const floorGeo = new THREE.PlaneGeometry(WIDTH, len);
                const ramp = new THREE.Mesh(floorGeo, mat);
                const midY = (H_BASE + H_SUB) / 2;
                ramp.position.set(0, midY, zStart - CONF.chunkLength/2);
                ramp.rotation.x = -Math.PI/2 + angle;
                chunk.mesh.add(ramp);

                const thick = new THREE.Mesh(new THREE.BoxGeometry(WIDTH, 2, len), new THREE.MeshBasicMaterial({color:0x111111}));
                thick.position.copy(ramp.position);
                thick.rotation.x = ramp.rotation.x;
                thick.translateY(-1.0);
                chunk.mesh.add(thick);
                
                const roofRamp = ramp.clone();
                roofRamp.position.y += 22;
                chunk.mesh.add(roofRamp);
                
                this.addWalls(chunk.mesh, midY, zStart, 0xaa00ff, true);
            }
            // RAMP: UP to SKY
            else if (type === 'ramp_up_high') {
                const len = Math.sqrt(CONF.chunkLength**2 + D_SKY**2);
                const angle = Math.atan(D_SKY / CONF.chunkLength);
                
                const floorGeo = new THREE.PlaneGeometry(WIDTH, len);
                const ramp = new THREE.Mesh(floorGeo, mat);
                const midY = (H_BASE + H_HIGH) / 2;
                ramp.position.set(0, midY, zStart - CONF.chunkLength/2);
                ramp.rotation.x = -Math.PI/2 + angle;
                chunk.mesh.add(ramp);

                const thick = new THREE.Mesh(new THREE.BoxGeometry(WIDTH, 2, len), new THREE.MeshBasicMaterial({color:0x111111}));
                thick.position.copy(ramp.position);
                thick.rotation.x = ramp.rotation.x;
                thick.translateY(-1.0);
                chunk.mesh.add(thick);
                
                const roofRamp = ramp.clone();
                roofRamp.position.y += 22;
                chunk.mesh.add(roofRamp);
            }
            // RAMP: DOWN from SKY
            else if (type === 'ramp_down_base') {
                const len = Math.sqrt(CONF.chunkLength**2 + D_SKY**2);
                const angle = Math.atan(D_SKY / CONF.chunkLength);
                
                const floorGeo = new THREE.PlaneGeometry(WIDTH, len);
                const ramp = new THREE.Mesh(floorGeo, mat);
                const midY = (H_BASE + H_HIGH) / 2;
                ramp.position.set(0, midY, zStart - CONF.chunkLength/2);
                ramp.rotation.x = -Math.PI/2 - angle;
                chunk.mesh.add(ramp);

                const thick = new THREE.Mesh(new THREE.BoxGeometry(WIDTH, 2, len), new THREE.MeshBasicMaterial({color:0x111111}));
                thick.position.copy(ramp.position);
                thick.rotation.x = ramp.rotation.x;
                thick.translateY(-1.0);
                chunk.mesh.add(thick);
                
                const roofRamp = ramp.clone();
                roofRamp.position.y += 22;
                chunk.mesh.add(roofRamp);
            }

            scene.add(chunk.mesh);
            this.chunks.push(chunk);
            this.nextZ = zEnd;

            // Spawn Obstacles / Collectibles
            if(!type.includes('ramp') && !type.includes('gap')) {
                const y = type === 'sub_level' ? H_SUB : (type === 'high_level' ? H_HIGH : H_BASE);
                
                if(Math.random() < 0.4) {
                    world.spawnCollectible(zStart - 10, 0, y + 5);
                    world.spawnCollectible(zStart - 25, CONF.laneWidth, y + 6);
                    world.spawnCollectible(zStart - 40, -CONF.laneWidth, y + 6);
                }

                const baseChance = 0.7;
                if(Math.random() < baseChance) {
                    [-1, 0, 1].forEach(lane => {
                        if(Math.random() < 0.6) {
                             world.spawnObstacle(zStart - CONF.chunkLength/2, lane, y);
                        }
                    });
                }
            }
        }

        addWalls(group, yLevel, zStart, color, isRamp=false) {
            // RESTORED WALLS
            const wallGeo = new THREE.BoxGeometry(1, 15, CONF.chunkLength);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const stickGeo = new THREE.BoxGeometry(0.5, 8, 0.5);
            const stickMat = new THREE.MeshBasicMaterial({ color: color });
            const dist = CONF.laneWidth * 1.5 + 3;

            [-dist, dist].forEach(x => {
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.set(x, yLevel + 6, zStart - CONF.chunkLength/2);
                if(isRamp) wall.rotation.x = group.children[0].rotation.x;
                group.add(wall);
                
                for(let k=0; k<3; k++) {
                    const stick = new THREE.Mesh(stickGeo, stickMat);
                    stick.position.set(x > 0 ? x-0.6 : x+0.6, yLevel + 4 + Math.random(), zStart - 10 - k*15);
                    group.add(stick);
                    const pl = new THREE.PointLight(color, 0.5, 10);
                    pl.position.copy(stick.position);
                    group.add(pl);
                }
            });
        }

        update(playerZ) {
            if (this.chunks.length === 0) return;
            if (playerZ < this.nextZ + 100) {
                const last = this.chunks[this.chunks.length-1].type;
                let next = 'flat';
                const r = Math.random();
                
                if(last === 'flat') {
                    if (r < 0.2) next = 'ramp_down_sub';
                    else if (r < 0.4) next = 'ramp_up_high';
                    else if (r < 0.6) next = 'gap_base'; 
                    else next = 'flat';
                }
                else if(last === 'sub_level') {
                     if(r < 0.3) next = 'ramp_up_base';
                     else if (r < 0.5) next = 'gap_sub';
                     else next = 'sub_level';
                }
                else if(last === 'high_level') next = r < 0.5 ? 'ramp_down_base' : 'high_level';
                
                else if(last === 'gap_base') next = 'flat';
                else if(last === 'gap_sub') next = 'sub_level';

                else if(last === 'ramp_down_sub') next = 'sub_level';
                else if(last === 'ramp_up_base') next = 'flat';
                else if(last === 'ramp_up_high') next = 'high_level';
                else if(last === 'ramp_down_base') next = 'flat';

                this.addChunk(next);
            }
            if(this.chunks.length > 0 && this.chunks[0].zEnd > playerZ + 50) {
                scene.remove(this.chunks[0].mesh);
                this.chunks.shift();
            }
        }

        getHeightAt(z) {
            const D_SUB = Math.abs(CONF.floorHeight - CONF.subLevelHeight);
            const D_SKY = Math.abs(CONF.skyHeight - CONF.floorHeight);

            for(let c of this.chunks) {
                if(z <= c.zStart && z >= c.zEnd) {
                    if (c.type === 'gap_base' || c.type === 'gap_sub') {
                        const relZ = c.zStart - z; 
                        if (relZ > 15 && relZ < 35) return -100; // THE PIT
                    }

                    const ratio = (c.zStart - z) / CONF.chunkLength; 
                    
                    if(c.type.includes('flat') || c.type === 'gap_base') return CONF.floorHeight;
                    if(c.type.includes('sub') || c.type === 'gap_sub') return CONF.subLevelHeight;
                    if(c.type === 'high_level') return CONF.skyHeight;
                    
                    if(c.type === 'ramp_down_sub') return CONF.floorHeight - (ratio * D_SUB);
                    if(c.type === 'ramp_up_base') return CONF.subLevelHeight + (ratio * D_SUB);
                    if(c.type === 'ramp_up_high') return CONF.floorHeight + (ratio * D_SKY);
                    if(c.type === 'ramp_down_base') return CONF.skyHeight - (ratio * D_SKY);
                }
            }
            return -100;
        }

        getCeilingAt(z) {
            const D_SUB = Math.abs(CONF.floorHeight - CONF.subLevelHeight);
            const D_SKY = Math.abs(CONF.skyHeight - CONF.floorHeight);
            for(let c of this.chunks) {
                if(z <= c.zStart && z >= c.zEnd) {
                    const ratio = (c.zStart - z) / CONF.chunkLength; 
                    
                    if(c.type.includes('flat') || c.type === 'gap_base') return CONF.floorHeight + 22;
                    if(c.type.includes('sub') || c.type === 'gap_sub') return CONF.subLevelHeight + 22;
                    if(c.type === 'high_level') return CONF.skyHeight + 22;

                    if(c.type === 'ramp_down_sub') return (CONF.floorHeight - (ratio * D_SUB)) + 22;
                    if(c.type === 'ramp_up_base') return (CONF.subLevelHeight + (ratio * D_SUB)) + 22;
                    if(c.type === 'ramp_up_high') return (CONF.floorHeight + (ratio * D_SKY)) + 22;
                    if(c.type === 'ramp_down_base') return (CONF.skyHeight - (ratio * D_SKY)) + 22;
                }
            }
            return 999; 
        }
    }

    // --- Background ---
    class Environment {
        constructor() {
            this.buildings = [];
            const geo = new THREE.CylinderGeometry(150, 150, 300, 32, 1, true);
            const mat = new THREE.ShaderMaterial({
                uniforms: { time: {value:0} },
                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                fragmentShader: `uniform float time; varying vec2 vUv; void main() { float glow = sin(vUv.y * 10.0 + time) * 0.5 + 0.5; gl_FragColor = vec4(0.0, 1.0, 0.5, glow * 0.3); }`,
                transparent: true, side: THREE.BackSide, blending: THREE.AdditiveBlending
            });
            this.aurora = new THREE.Mesh(geo, mat);
            this.aurora.rotation.x = Math.PI/2;
            scene.add(this.aurora);

            const box = new THREE.BoxGeometry(10, 50, 10);
            const bMat = new THREE.MeshBasicMaterial({ color: 0x000022 });
            const detailMat = new THREE.MeshBasicMaterial({color: 0x00ffff});

            for(let i=0; i<40; i++) {
                const m = new THREE.Mesh(box, bMat);
                let x = (Math.random() - 0.5) * 400;
                if(Math.abs(x) < 50) x = x < 0 ? -60 - Math.random()*50 : 60 + Math.random()*50;
                
                m.position.set(x, -25, -50 - Math.random()*200);
                m.scale.y = 1 + Math.random()*3;
                const ant = new THREE.Mesh(new THREE.BoxGeometry(0.5, 10, 0.5), detailMat);
                ant.position.y = 25; m.add(ant);
                scene.add(m);
                this.buildings.push(m);
            }
        }
        update(z) {
            this.aurora.position.z = z - 50;
            this.aurora.material.uniforms.time.value = timeGlobal;
            this.buildings.forEach(b => { if(b.position.z > z + 20) b.position.z -= 300; });
        }
    }

    // --- Player ---
    class Player {
        constructor() {
            this.lane = 0; this.targetX = 0; this.isEthereal = false;
            this.vy = 0; this.jumpCount = 0; this.isJumping = false;
            this.flipType = 'front'; 
            
            this.container = new THREE.Group();
            this.container.position.y = 2; 
            scene.add(this.container);
            
            this.materials = {}; // Store materials to change color
            this.createModel();

            // Headlight
            this.light = new THREE.SpotLight(0xffffff, 1.5, 60, 0.5, 0.5, 1);
            this.light.position.set(0, 5, 2);
            
            const targetObject = new THREE.Object3D();
            targetObject.position.set(0, -5, -10);
            this.light.target = targetObject;
            
            this.container.add(this.light);
            this.container.add(targetObject);
            
            this.updateAppearance();
        }

        createModel() {
            // Colors will be updated dynamically
            this.materials.armor = new THREE.MeshStandardMaterial({ color: CONF.colors.armor, roughness: 0.3, metalness: 0.8 });
            this.materials.glow = new THREE.MeshBasicMaterial({ color: 0x00ffff }); // Default Cyan (Solid)
            
            const matArmor = this.materials.armor;
            const matGlow = this.materials.glow;

            this.hips = new THREE.Group();
            this.container.add(this.hips);

            const pelvis = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.3), matArmor);
            this.hips.add(pelvis);

            this.torso = new THREE.Group();
            this.torso.position.y = 0.1;
            this.hips.add(this.torso);
            const spine = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.25), matArmor);
            spine.position.y = 0.3;
            const chest = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.3), matArmor);
            chest.position.y = 0.5;
            const reactor = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), matGlow);
            reactor.position.set(0, 0.5, 0.16);
            this.torso.add(spine, chest, reactor);

            this.head = new THREE.Group();
            this.head.position.y = 0.7;
            this.torso.add(this.head);
            const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.35, 0.35), new THREE.MeshStandardMaterial({color: CONF.colors.helmet}));
            const visor = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.1, 0.2), matGlow);
            visor.position.set(0, 0, 0.1); 
            this.head.add(helmet, visor);

            const createLimb = (w, h, d) => {
                const g = new THREE.Group();
                const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), matArmor);
                m.position.y = -h/2; 
                const strip = new THREE.Mesh(new THREE.BoxGeometry(w*0.5, h*0.8, d*1.1), matGlow);
                strip.position.y = -h/2;
                g.add(m, strip);
                return g;
            };

            this.L_Thigh = createLimb(0.2, 0.5, 0.2); this.L_Thigh.position.set(-0.2, 0, 0); this.hips.add(this.L_Thigh);
            this.L_Shin = createLimb(0.18, 0.5, 0.18); this.L_Shin.position.y = -0.5; this.L_Thigh.add(this.L_Shin);
            this.R_Thigh = createLimb(0.2, 0.5, 0.2); this.R_Thigh.position.set(0.2, 0, 0); this.hips.add(this.R_Thigh);
            this.R_Shin = createLimb(0.18, 0.5, 0.18); this.R_Shin.position.y = -0.5; this.R_Thigh.add(this.R_Shin);

            this.L_Arm = createLimb(0.15, 0.4, 0.15); this.L_Arm.position.set(-0.35, 0.6, 0); this.torso.add(this.L_Arm);
            this.L_Forearm = createLimb(0.12, 0.4, 0.12); this.L_Forearm.position.y = -0.4; this.L_Arm.add(this.L_Forearm);
            this.R_Arm = createLimb(0.15, 0.4, 0.15); this.R_Arm.position.set(0.35, 0.6, 0); this.torso.add(this.R_Arm);
            this.R_Forearm = createLimb(0.12, 0.4, 0.12); this.R_Forearm.position.y = -0.4; this.R_Arm.add(this.R_Forearm);
        }

        updateAppearance() {
            if (this.isEthereal) {
                // Ethereal: Red Glow, Transparent
                this.materials.glow.color.setHex(0xff0044);
                this.materials.armor.transparent = true;
                this.materials.armor.opacity = 0.4;
                this.materials.armor.emissive.setHex(0x330000);
            } else {
                // Solid: Cyan Glow, Solid
                this.materials.glow.color.setHex(0x00ffff);
                this.materials.armor.transparent = false;
                this.materials.armor.opacity = 1.0;
                this.materials.armor.emissive.setHex(0x001111);
            }
        }

        update(dt) {
            // Snappier Lane Switch
            this.container.position.x += (this.targetX - this.container.position.x) * 15 * dt;
            
            const floorY = chunkManager.getHeightAt(this.container.position.z);
            const ceilingY = chunkManager.getCeilingAt(this.container.position.z);
            
            this.vy -= CONF.gravity;
            this.container.position.y += this.vy;

            this.light.target.position.set(0, -5, -10);

            if (this.container.position.y < -20) {
                gameOver();
            }

            if(this.container.position.y + 2.0 > ceilingY) {
                this.container.position.y = ceilingY - 2.0;
                this.vy = -0.1;
            }

            const legLen = 1.0; 
            if (this.container.position.y <= floorY + legLen) {
                if (floorY > -20) {
                    this.container.position.y = floorY + legLen;
                    this.vy = 0; 
                    this.jumpCount = 0; 
                    this.isJumping = false;
                    this.hips.rotation.x = 0; 
                    this.hips.rotation.y = 0; 
                    this.hips.rotation.z = 0;
                    this.container.rotation.x = 0;
                }
            } else {
                this.isJumping = true;
                if (this.jumpCount > 0) {
                    const flipSpeed = 0.25;
                    if(this.flipType === 'front') {
                        this.hips.rotation.x -= flipSpeed;
                        this.L_Thigh.rotation.x = 1.5; this.R_Thigh.rotation.x = 1.5;
                        this.L_Shin.rotation.x = 2.0; this.R_Shin.rotation.x = 2.0;
                    } else if (this.flipType === 'side') {
                         this.hips.rotation.z -= flipSpeed;
                         this.L_Thigh.rotation.x = 1.0; this.R_Thigh.rotation.x = 0.5;
                         this.L_Shin.rotation.x = 1.5; this.R_Shin.rotation.x = 1.5;
                         this.hips.rotation.x = 0.5;
                    }
                }
            }

            // Running Animation
            if (!this.isJumping) {
                const runSpeed = 18;
                const t = timeGlobal * runSpeed;
                this.hips.position.y = Math.abs(Math.sin(t)) * 0.1;
                this.hips.rotation.x = 0.2; 
                this.torso.rotation.y = Math.cos(t) * 0.2; 
                this.torso.rotation.z = Math.cos(t) * 0.05;
                this.L_Thigh.rotation.x = Math.sin(t) * 1.0;
                this.L_Shin.rotation.x = 0.2 + Math.max(0, Math.sin(t + 0.5)) * 1.8;
                this.R_Thigh.rotation.x = Math.sin(t + Math.PI) * 1.0;
                this.R_Shin.rotation.x = 0.2 + Math.max(0, Math.sin(t + Math.PI + 0.5)) * 1.8;
                this.L_Arm.rotation.x = Math.sin(t + Math.PI) * 0.9; 
                this.L_Arm.rotation.z = 0.1; 
                this.L_Forearm.rotation.x = -1.0 - Math.abs(Math.sin(t)) * 0.5;
                this.R_Arm.rotation.x = Math.sin(t) * 0.9;
                this.R_Arm.rotation.z = -0.1;
                this.R_Forearm.rotation.x = -1.0 - Math.abs(Math.sin(t + Math.PI)) * 0.5;
            }
        }

        move(d) { 
            this.lane = Math.max(-1, Math.min(1, this.lane+d)); 
            this.targetX = this.lane * CONF.laneWidth; 
        }
        
        jump() { 
            if(this.jumpCount < 2) { 
                this.vy = CONF.jumpForce; this.jumpCount++; 
                this.flipType = Math.random() > 0.5 ? 'front' : 'side';
                AudioSys.playJump(); 
            } 
        }
        
        toggle() { 
            this.isEthereal = !this.isEthereal; AudioSys.playShift(); 
            this.updateAppearance();
            particles.push(new PhaseEffect(this.container.position, this.isEthereal ? 0xff0044 : 0x00ffff));
            const el = document.getElementById('mode-indicator');
            el.innerText = this.isEthereal ? "ETHEREAL" : "SOLID";
            el.className = this.isEthereal ? "mode-ethereal" : "mode-solid";
        }
    }

    // --- World Objects ---
    const world = {
        obstacles: [],
        collectibles: [],
        spawnObstacle: function(z, lane, y) {
            const x = lane * CONF.laneWidth;
            const type = Math.random();
            const grp = new THREE.Group();
            grp.position.set(x, y, z);
            grp.userData = { type: 'none', active: true };

            const CEIL_HEIGHT = 20; 

            if(type < 0.5) { 
                grp.userData.type = 'laser';
                const mat = new THREE.MeshBasicMaterial({color: CONF.colors.laser});
                for(let k=0; k<12; k++) {
                    const b = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,3.8), mat);
                    b.rotation.z = Math.PI/2; b.position.y = 1 + k*0.6; grp.add(b);
                }
                
                // WIDENED POSTS (Grey things fixed)
                const postColor = 0x050505; // Almost black, blends in
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.3, CEIL_HEIGHT, 0.3), new THREE.MeshStandardMaterial({color: postColor}));
                p.position.set(-3.5, CEIL_HEIGHT/2, 0); // Moved out from 2.5
                grp.add(p);
                const p2 = p.clone(); p2.position.set(3.5, CEIL_HEIGHT/2, 0); // Moved out from 2.5
                grp.add(p2);
            } else { 
                grp.userData.type = 'glass';
                const mat = new THREE.MeshPhysicalMaterial({color: 0xffffff, transmission: 0.9, thickness: 1.0, roughness: 0.0, metalness: 0.1 });
                const glass = new THREE.Mesh(new THREE.BoxGeometry(6.5, CEIL_HEIGHT, 0.2), mat); // Wider Glass
                glass.position.y = CEIL_HEIGHT/2;
                grp.add(glass);
                const frameGeo = new THREE.BoxGeometry(6.7, CEIL_HEIGHT, 0.4); // Wider Frame
                const frame = new THREE.Mesh(frameGeo, new THREE.MeshBasicMaterial({color: 0x00ffff, wireframe: true}));
                frame.position.y = CEIL_HEIGHT/2;
                grp.add(frame);
            }

            scene.add(grp);
            this.obstacles.push(grp);
        },
        spawnCollectible: function(z, x, y) {
            const grp = new THREE.Group();
            grp.position.set(x, y, z);
            grp.rotation.z = Math.PI / 4;
            grp.userData = { type: 'collectible', active: true };
            
            const geo = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
            const mat = new THREE.MeshBasicMaterial({ color: CONF.colors.glowStick });
            const mesh = new THREE.Mesh(geo, mat);
            grp.add(mesh);
            
            const light = new THREE.PointLight(CONF.colors.glowStick, 1, 5);
            grp.add(light);
            
            scene.add(grp);
            this.collectibles.push(grp);
        },
        update: function(playerZ) {
            for(let i = this.obstacles.length - 1; i >= 0; i--) {
                const ob = this.obstacles[i];
                if(ob.position.z > playerZ + 20) {
                    scene.remove(ob);
                    this.obstacles.splice(i, 1);
                }
            }
            for(let i = this.collectibles.length - 1; i >= 0; i--) {
                const c = this.collectibles[i];
                c.rotation.y += 0.05;
                c.rotation.z += 0.02;
                if(c.position.z > playerZ + 20) {
                    scene.remove(c);
                    this.collectibles.splice(i, 1);
                }
            }
        },
        reset: function() {
            this.obstacles.forEach(o => scene.remove(o));
            this.collectibles.forEach(c => scene.remove(c));
            this.obstacles = [];
            this.collectibles = [];
        }
    };

    // --- Main Systems ---
    let chunkManager;
    let env;
    let player;

    function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONF.colors.bg, 0.015);
        scene.background = new THREE.Color(CONF.colors.bg);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 300);
        camera.position.set(0, 5, 10);

        renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('game-container').appendChild(renderer.domElement);

        chunkManager = new ChunkManager();
        env = new Environment();

        for(let i=0; i<15; i++) {
            speedLines.push(new SpeedLine());
        }

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x000000, 0.6);
        scene.add(hemiLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        AudioSys.init();

        document.addEventListener('keydown', handleInput);
        window.addEventListener('resize', onResize);

        requestAnimationFrame(animate);
    }

    function startGame() {
        if(gameActive) return;
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('ui-layer').classList.remove('hidden');
        
        AudioSys.resume();
        score = 0;
        currency = 0;
        speed = CONF.speed;
        chunkManager.reset();
        world.reset();
        
        if(player) scene.remove(player.container);
        player = new Player();
        
        gameActive = true;
    }

    function gameOver() {
        gameActive = false;
        AudioSys.playCrash();
        document.getElementById('final-score').innerText = Math.floor(score) + " (GLOW: " + currency + ")";
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function handleInput(e) {
        if (e.code === 'Space') {
            if(!gameActive) {
                if(!document.getElementById('game-over-screen').classList.contains('hidden')) startGame();
                else if(!document.getElementById('start-screen').classList.contains('hidden')) startGame();
                else player.jump();
            } else {
                player.jump();
            }
        }
        if(!gameActive) return;

        if (e.code === 'ArrowLeft') player.move(-1);
        if (e.code === 'ArrowRight') player.move(1);
        if (e.code === 'ArrowDown') player.toggle();
    }

    function checkCollisions() {
        const pBox = new THREE.Box3().setFromObject(player.hips);
        pBox.expandByScalar(-0.2);

        for(let ob of world.obstacles) {
            if(ob.position.z < player.container.position.z - 2 || ob.position.z > player.container.position.z + 2) continue;
            const obBox = new THREE.Box3().setFromObject(ob);
            if(pBox.intersectsBox(obBox)) {
                const type = ob.userData.type;
                let survive = false;
                if (type === 'laser') {
                    if (player.isEthereal) survive = true;
                } else if (type === 'glass') {
                    if (!player.isEthereal) {
                        survive = true;
                        particles.push(new PhaseEffect(ob.position, 0x00ffff));
                        scene.remove(ob);
                        world.obstacles = world.obstacles.filter(o => o !== ob);
                        AudioSys.playShift(); 
                    }
                }
                if (!survive) gameOver();
            }
        }

        const pSphere = new THREE.Sphere(player.container.position.clone(), 1.5);
        pSphere.center.y += 1;
        
        for(let i = world.collectibles.length - 1; i >= 0; i--) {
            const c = world.collectibles[i];
            if(c.position.distanceTo(pSphere.center) < 2.0) {
                 currency += 10;
                 document.getElementById('currency-display').innerText = "GLOW: " + currency;
                 scene.remove(c);
                 world.collectibles.splice(i, 1);
                 AudioSys.playCollect();
                 particles.push(new PhaseEffect(c.position, 0xffff00));
            }
        }
    }

    function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        const dt = 0.016; 
        timeGlobal += dt;

        if(gameActive) {
            speed += 0.0001;
            score += speed;
            document.getElementById('score-display').innerText = 'SCORE: ' + Math.floor(score).toString().padStart(4, '0');
            document.getElementById('speed-display').innerText = 'VELOCITY: ' + Math.floor((speed/CONF.speed)*100) + '%';

            player.container.position.z -= speed;
            player.update(dt);

            camera.position.z = player.container.position.z + 14;
            camera.position.y = THREE.MathUtils.lerp(camera.position.y, player.container.position.y + 4, 0.1);
            
            const targetCamX = player.container.position.x * 0.7;
            camera.position.x += (targetCamX - camera.position.x) * 0.1;
            
            camera.lookAt(player.container.position.x * 0.3, player.container.position.y, player.container.position.z - 15);
            
            const targetTilt = -player.container.position.x * 0.05;
            camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, targetTilt, 0.1);

            chunkManager.update(player.container.position.z);
            world.update(player.container.position.z);
            env.update(player.container.position.z);
            
            speedLines.forEach(sl => sl.update(player.container.position.z));
            
            checkCollisions();
        } else {
             if(!player && camera) {
                 camera.position.x = Math.sin(timeGlobal * 0.2) * 5;
                 camera.lookAt(0,0,-20);
             }
        }

        for(let i = particles.length - 1; i >= 0; i--) {
            particles[i].update();
            if(!particles[i].active) particles.splice(i, 1);
        }

        renderer.render(scene, camera);
    }

    init();

</script>
</body>
</html>
